<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="light" />
  <title>Word Practice 1–400</title>
  <style>
    :root{
      --bg:#fbfbf9;
      --panel:#ffffff;
      --text:#111214;
      --muted:#5b6068;
      --border:#d9dde3;
      --shadow: 0 10px 30px rgba(17,18,20,.06);
      --accent:#1f2a44;
      --radius:14px;
      --radius-sm:10px;
      --fade:.26s;
      --ok:#0f5132;
      --ng:#842029;
      --okbg:rgba(15,81,50,.08);
      --ngbg:rgba(132,32,41,.08);
      --maru:#d11f2a; /* correct: red circle */
      --batsu:#1c4fd6; /* wrong: blue cross */
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Sans", "Hiragino Kaku Gothic ProN", Meiryo, Arial, sans-serif;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .app{
      min-height:100%;
      display:flex;
      flex-direction:column;
      align-items:center;
    }

    .topbar{
      width:100%;
      max-width:980px;
      padding:14px 18px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    .brand{
      display:flex;
      align-items:baseline;
      gap:10px;
      min-width:0;
    }
    .brand-title{
      font-weight:650;
      letter-spacing:.02em;
      color:var(--accent);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .brand-sub{
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .icon-btn{
      appearance:none;
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--accent);
      border-radius:999px;
      width:40px;
      height:40px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      box-shadow: 0 2px 10px rgba(17,18,20,.04);
      transition: transform var(--fade) ease, opacity var(--fade) ease, background var(--fade) ease;
    }
    .icon-btn:active{ transform: translateY(1px); }
    .icon-btn[disabled]{ opacity:.45; cursor:not-allowed; }

    main{
      width:100%;
      max-width:980px;
      padding: 0 18px 110px;
      display:flex;
      justify-content:center;
    }

    .stage{
      width:100%;
      max-width:720px;
    }

    .view{ display:none; }
    .view.active{ display:block; }

    /* Title view */
    .hero{
      background: linear-gradient(180deg, rgba(31,42,68,.06), rgba(31,42,68,0) 62%);
      border:1px solid var(--border);
      border-radius: var(--radius);
      padding: 22px 22px 20px;
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .hero::after{
      content:"";
      position:absolute;
      inset:-40% -30%;
      background: radial-gradient(closest-side, rgba(31,42,68,.10), rgba(31,42,68,0));
      opacity:.45;
      pointer-events:none;
    }

    .h1{
      margin:0;
      font-size:26px;
      font-weight:720;
      letter-spacing:.02em;
      color:var(--accent);
    }
    .subtitle{
      margin:10px 0 0;
      color:var(--muted);
      font-size:14px;
      line-height:1.6;
    }

    .section{
      margin-top:14px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .section-title{
      font-size:12px;
      color:var(--muted);
      letter-spacing:.08em;
      text-transform:uppercase;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .section-title .right{
      font-size:12px;
      color:var(--muted);
      letter-spacing:normal;
      text-transform:none;
    }

    .actions{
      margin-top:8px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    @media (max-width:520px){
      .actions{ grid-template-columns:1fr; }
    }

    .btn{
      appearance:none;
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--text);
      border-radius: var(--radius-sm);
      padding: 14px 14px;
      cursor:pointer;
      text-align:left;
      box-shadow: 0 2px 12px rgba(17,18,20,.04);
      transition: transform var(--fade) ease, border-color var(--fade) ease, opacity var(--fade) ease;
      display:flex;
      flex-direction:column;
      gap:4px;
      min-height:58px;
    }
    .btn:hover{ border-color: rgba(31,42,68,.32); }
    .btn:active{ transform: translateY(1px); }
    .btn[disabled]{ opacity:.45; cursor:not-allowed; }

    .btn .label{
      font-weight:650;
      letter-spacing:.01em;
      color:var(--accent);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .btn .desc{
      font-size:12px;
      color:var(--muted);
      line-height:1.5;
    }

    .fineprint{
      margin-top:14px;
      font-size:12px;
      color:var(--muted);
      line-height:1.6;
      display:flex;
      align-items:flex-start;
      gap:8px;
    }
    .badge{
      border:1px solid var(--border);
      background: rgba(255,255,255,.7);
      border-radius:999px;
      padding:2px 8px;
      font-size:11px;
      color:var(--muted);
      white-space:nowrap;
    }

    /* Seg (tabs) */
    .seg{
      display:inline-flex;
      border:1px solid rgba(31,42,68,.18);
      border-radius:999px;
      overflow:hidden;
      background:#fff;
      flex-shrink:0;
    }
    .seg button{
      appearance:none;
      border:0;
      background:transparent;
      padding:9px 12px;
      font-size:12px;
      cursor:pointer;
      color:var(--muted);
      transition: background var(--fade) ease, color var(--fade) ease;
      white-space:nowrap;
    }
    .seg button.active{
      background: rgba(31,42,68,.10);
      color: var(--accent);
      font-weight:650;
    }

    /* Quiz view */
    .quiz-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin: 4px 2px 10px;
    }
    .pill{
      border:1px solid var(--border);
      border-radius:999px;
      padding:6px 10px;
      font-size:12px;
      color:var(--muted);
      background: rgba(255,255,255,.7);
      white-space:nowrap;
    }
    .progress{
      font-size:12px;
      color:var(--muted);
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    .progress strong{ color:var(--accent); }

    .card{
      position:relative;
      overflow:hidden;
      border:1px solid var(--border);
      border-radius: var(--radius);
      background:var(--panel);
      box-shadow: var(--shadow);
      padding: 18px 18px 16px;
      transition: opacity var(--fade) ease, transform var(--fade) ease;
    }
    .card.fade-out{
      opacity:0;
      transform: translateY(2px);
    }

    .mark-layer{
      position:absolute;
      top:10px;
      right:10px;
      width:74px;
      height:74px;
      pointer-events:none;
      opacity:0;
      transform: translateY(-2px) scale(.98);
      transition: opacity .18s ease, transform .18s ease;
      filter: drop-shadow(0 8px 18px rgba(17,18,20,.10));
    }
    .mark-layer.show{
      opacity:1;
      transform: translateY(0) scale(1);
    }
    .mark-layer svg{
      width:100%;
      height:100%;
      display:block;
    }
    .mark-layer .ring{
      fill:none;
      stroke: var(--maru);
      stroke-width:8.5;
      stroke-linecap:round;
      stroke-dasharray: 310;
      stroke-dashoffset: 310;
    }
    .mark-layer .xline{
      stroke: var(--batsu);
      stroke-width:9;
      stroke-linecap:round;
      stroke-dasharray: 120;
      stroke-dashoffset: 120;
    }
    .mark-layer.ok .ring{ animation: drawRing .55s ease forwards; }
    .mark-layer.ng .x1{ animation: drawLine .40s ease forwards; }
    .mark-layer.ng .x2{ animation: drawLine .40s .10s ease forwards; }

    @keyframes drawRing{ to{ stroke-dashoffset: 0; } }
    @keyframes drawLine{ to{ stroke-dashoffset: 0; } }

    .meta{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      margin-bottom:10px;
    }
    .no{
      font-size:12px;
      color:var(--muted);
    }
    .dir{
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .judge{
      font-size:11px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(31,42,68,.16);
      background: rgba(255,255,255,.7);
      color: var(--muted);
    }
    .judge.ok{
      border-color: rgba(15,81,50,.22);
      background: var(--okbg);
      color: var(--ok);
      font-weight:650;
    }
    .judge.ng{
      border-color: rgba(132,32,41,.22);
      background: var(--ngbg);
      color: var(--ng);
      font-weight:650;
    }

    .prompt{
      font-size:26px;
      font-weight:720;
      letter-spacing:.02em;
      line-height:1.2;
      color:var(--text);
      word-break:break-word;
    }

    .answer-wrap{
      margin-top:14px;
      padding-top:14px;
      border-top:1px dashed rgba(31,42,68,.18);
    }
    .answer-label{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.10em;
      color:var(--muted);
      margin-bottom:6px;
    }
    .answer{
      font-size:18px;
      line-height:1.55;
      color:var(--accent);
      word-break:break-word;
    }
    .hidden{ display:none !important; }

    .hand-wrap{
      margin-top:12px;
      padding-top:12px;
      border-top:1px dashed rgba(31,42,68,.18);
    }
    .hand-title{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.10em;
      color:var(--muted);
      margin-bottom:8px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .hand-title .mini{
      font-size:11px;
      color:var(--muted);
      letter-spacing:normal;
      text-transform:none;
      white-space:nowrap;
    }
    .hand-canvas{
      width:100%;
      height:220px;
      border:1px solid var(--border);
      border-radius:12px;
      background:#fff;
      display:block;
      touch-action:none;
      box-shadow: 0 2px 10px rgba(17,18,20,.04) inset;
    }
    .hand-controls{
      margin-top:8px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .hand-controls .left,
    .hand-controls .right{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .hand-note{
      font-size:12px;
      color:var(--muted);
      line-height:1.5;
    }

    .spell-wrap{
      margin-top:12px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .spell-row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .spell-label{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.10em;
      color:var(--muted);
    }
    .spell-input{
      flex:1 1 240px;
      min-width:220px;
      border:1px solid var(--border);
      border-radius:12px;
      padding:12px 12px;
      font-size:18px;
      line-height:1.2;
      outline:none;
      background:#fff;
      box-shadow: 0 2px 10px rgba(17,18,20,.04) inset;
    }
    .spell-input:disabled{ opacity:.65; }

    .controls{
      margin-top:12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .controls .left,
    .controls .right{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    .cta{
      appearance:none;
      border:1px solid rgba(31,42,68,.24);
      background: rgba(31,42,68,.06);
      color:var(--accent);
      border-radius: 999px;
      padding: 10px 14px;
      cursor:pointer;
      font-weight:650;
      letter-spacing:.01em;
      transition: transform var(--fade) ease, background var(--fade) ease, opacity var(--fade) ease;
    }
    .cta:hover{ background: rgba(31,42,68,.085); }
    .cta:active{ transform: translateY(1px); }
    .cta[disabled]{ opacity:.50; cursor:not-allowed; }

    .navbtn{
      appearance:none;
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--text);
      border-radius: 999px;
      padding: 10px 14px;
      cursor:pointer;
      transition: transform var(--fade) ease, opacity var(--fade) ease, border-color var(--fade) ease;
    }
    .navbtn:hover{ border-color: rgba(31,42,68,.32); }
    .navbtn:active{ transform: translateY(1px); }
    .navbtn[disabled]{ opacity:.45; cursor:not-allowed; }

    .hint{
      margin-top:10px;
      font-size:12px;
      color:var(--muted);
      line-height:1.6;
      padding-left:2px;
    }

    .debug-bar{
      margin-top:10px;
      font-size:11px;
      color:var(--muted);
      line-height:1.5;
      padding: 10px 12px;
      border:1px dashed rgba(31,42,68,.18);
      border-radius: var(--radius-sm);
      background: rgba(255,255,255,.6);
    }
    .debug-bar strong{ color: var(--accent); }
    .debug-bar:empty{ display:none; }

    /* Result view */
    .result-box{
      margin-top:12px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.70);
      border-radius: var(--radius);
      padding: 14px 14px;
      box-shadow: 0 2px 10px rgba(17,18,20,.04);
    }
    .scoreline{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .scorebig{
      font-size:34px;
      font-weight:760;
      letter-spacing:.01em;
      color: var(--accent);
    }
    .scoresub{
      font-size:12px;
      color: var(--muted);
    }
    details{
      margin-top:12px;
      border:1px dashed rgba(31,42,68,.18);
      border-radius: var(--radius-sm);
      background: rgba(255,255,255,.55);
      padding: 10px 12px;
    }
    summary{
      cursor:pointer;
      color: var(--accent);
      font-weight:650;
      list-style:none;
    }
    summary::-webkit-details-marker{ display:none; }
    .wrong-list{
      margin:10px 0 0;
      padding:0;
      list-style:none;
      display:flex;
      flex-direction:column;
      gap:8px;
      color: var(--text);
    }
    .wrong-item{
      border:1px solid rgba(31,42,68,.10);
      border-radius: 12px;
      padding: 10px 10px;
      background: rgba(31,42,68,.03);
    }
    .wrong-item .top{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:baseline;
      flex-wrap:wrap;
      margin-bottom:6px;
      color: var(--muted);
      font-size:12px;
    }
    .wrong-item .mid{
      font-size:14px;
      line-height:1.55;
    }
    .wrong-item code{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12.5px;
      background: rgba(255,255,255,.7);
      border:1px solid rgba(31,42,68,.12);
      border-radius: 8px;
      padding: 2px 6px;
    }

    /* Overlay settings */
    .overlay{
      position:fixed;
      inset:0;
      background: rgba(17,18,20,.32);
      display:flex;
      justify-content:center;
      align-items:flex-end;
      padding: 18px;
      z-index:50;
      transition: opacity var(--fade) ease;
    }
    .overlay.hidden{ display:none; }

    .sheet{
      width:100%;
      max-width:720px;
      border-radius: var(--radius);
      background: var(--panel);
      border:1px solid var(--border);
      box-shadow: 0 24px 80px rgba(17,18,20,.24);
      overflow:hidden;
    }
    .sheet-header{
      padding: 14px 16px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .sheet-title{
      font-weight:700;
      letter-spacing:.02em;
      color:var(--accent);
    }
    .sheet-body{
      padding: 14px 16px 16px;
      display:grid;
      gap:14px;
    }

    .setting{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:14px;
      padding: 12px 12px;
      border:1px solid rgba(31,42,68,.12);
      border-radius: var(--radius-sm);
      background: rgba(31,42,68,.03);
    }
    .setting .text{
      min-width:0;
    }
    .setting .name{
      font-weight:650;
      color:var(--text);
      margin-bottom:3px;
    }
    .setting .note{
      font-size:12px;
      color:var(--muted);
      line-height:1.5;
    }

    .toggle{
      display:flex;
      align-items:center;
      gap:10px;
      flex-shrink:0;
      user-select:none;
    }
    .toggle input{
      width:44px;
      height:26px;
      appearance:none;
      background: rgba(31,42,68,.12);
      border:1px solid rgba(31,42,68,.14);
      border-radius:999px;
      position:relative;
      outline:none;
      cursor:pointer;
      transition: background var(--fade) ease;
    }
    .toggle input::after{
      content:"";
      width:20px;
      height:20px;
      background:#fff;
      border:1px solid rgba(31,42,68,.18);
      border-radius:999px;
      position:absolute;
      top:50%;
      left:3px;
      transform: translateY(-50%);
      box-shadow: 0 4px 14px rgba(17,18,20,.12);
      transition: left var(--fade) ease;
    }
    .toggle input:checked{
      background: rgba(31,42,68,.26);
    }
    .toggle input:checked::after{
      left:21px;
    }

    .sheet-footer{
      padding: 12px 16px;
      border-top:1px solid var(--border);
      display:flex;
      justify-content:flex-end;
      gap:10px;
    }

    .textbtn{
      appearance:none;
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--text);
      border-radius:999px;
      padding:10px 14px;
      cursor:pointer;
      transition: transform var(--fade) ease, border-color var(--fade) ease;
    }
    .textbtn:hover{ border-color: rgba(31,42,68,.32); }
    .textbtn:active{ transform: translateY(1px); }

    /* corner footer */
    .corner{
      position:fixed;
      right:10px;
      bottom:10px;
      z-index:10;
      pointer-events:none;
      opacity:.70;
    }
    .version{
      font-size:11px;
      color:var(--muted);
      text-align:right;
      line-height:1.35;
      background: rgba(255,255,255,.65);
      border:1px solid rgba(31,42,68,.10);
      border-radius:10px;
      padding:7px 9px;
      box-shadow: 0 6px 24px rgba(17,18,20,.06);
      backdrop-filter: blur(6px);
    }

    @media (prefers-reduced-motion: reduce){
      *{ transition:none !important; }
      .mark-layer.ok .ring,
      .mark-layer.ng .x1,
      .mark-layer.ng .x2{ animation:none !important; stroke-dashoffset:0 !important; }
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <header class="topbar">
      <button class="icon-btn" id="backBtn" aria-label="タイトルへ戻る" title="タイトルへ戻る" disabled>←</button>

      <div class="brand" aria-label="アプリ名">
        <div class="brand-title">Word Practice 1–400</div>
        <div class="brand-sub">confirmed list / offline</div>
      </div>

      <button class="icon-btn" id="settingsBtn" aria-label="設定" title="設定">⚙</button>
    </header>

    <main>
      <div class="stage">
        <!-- Title -->
        <section class="view active" id="viewTitle" aria-label="タイトル画面">
          <div class="hero">
            <h1 class="h1">Word Practice 1–400</h1>
            <p class="subtitle">
              学習用のシンプルな単語ビューア。範囲（Vocabu）を選んで練習します。
            </p>

            <div class="section">
              <div class="section-title">
                <span>Vocabu Mode</span>
                <span class="right" id="deckStatus">—</span>
              </div>
              <div class="seg" role="tablist" aria-label="Vocabu range">
                <button type="button" id="deckABtn" class="active" role="tab" aria-selected="true">0〜200</button>
                <button type="button" id="deckBBtn" role="tab" aria-selected="false">200〜400</button>
                <button type="button" id="deckAllBtn" role="tab" aria-selected="false">ALL</button>
              </div>
            </div>

            <div class="section">
              <div class="section-title"><span>Practice</span><span class="right" id="practiceHint">—</span></div>

              <div class="actions">
                <button class="btn" id="startSeqBtn">
                  <div class="label"><span>順番</span><span class="badge" id="badgeSeq">—</span></div>
                  <div class="desc">選択範囲を番号順で確認</div>
                </button>
                <button class="btn" id="startRevBtn">
                  <div class="label"><span>逆順</span><span class="badge" id="badgeRev">—</span></div>
                  <div class="desc">選択範囲を逆から確認</div>
                </button>

                <button class="btn" id="startRndBtn">
                  <div class="label"><span>ランダム（1周）</span><span class="badge" id="badgeRnd">—</span></div>
                  <div class="desc">重複なしで1周</div>
                </button>
                <button class="btn" id="startLoopBtn">
                  <div class="label"><span>ランダム周回（2周）</span><span class="badge" id="badgeLoop">—</span></div>
                  <div class="desc">2周ぶん（重複あり）で回転練習</div>
                </button>

                <button class="btn" id="startExamBtn">
                  <div class="label"><span>本番（100問）</span><span class="badge" id="badgeExam">—</span></div>
                  <div class="desc">選択範囲から100語を抽選（重複なし）</div>
                </button>
                <button class="btn" id="startHandBtn">
                  <div class="label"><span>手書き本番（100問）</span><span class="badge" id="badgeHand">—</span></div>
                  <div class="desc">日→英で判定、最後にスコア</div>
                </button>
              </div>

              <div class="fineprint" id="titleDebug">
                <span class="badge">Data</span>
                <span id="dataStatusText">loading…</span>
              </div>
            </div>
          </div>
        </section>

        <!-- Quiz -->
        <section class="view" id="viewQuiz" aria-label="問題画面">
          <div class="quiz-header">
            <div class="progress" id="progressWrap">
              <span id="progressText">—</span>
            </div>
            <div class="pill" id="modePill">—</div>
          </div>

          <div class="card" id="card">
            <div class="mark-layer hidden" id="markLayer" aria-hidden="true">
              <!-- correct (red circle) -->
              <svg class="svg-ok hidden" id="svgOk" viewBox="0 0 120 120">
                <circle class="ring" cx="60" cy="60" r="44"></circle>
              </svg>
              <!-- wrong (blue cross) -->
              <svg class="svg-ng hidden" id="svgNg" viewBox="0 0 120 120">
                <line class="xline x1" x1="34" y1="34" x2="86" y2="86"></line>
                <line class="xline x2" x1="86" y1="34" x2="34" y2="86"></line>
              </svg>
            </div>

            <div class="meta">
              <div class="no" id="noText">No.—</div>
              <div class="dir" id="dirText">
                <span id="dirLabel">—</span>
                <span class="judge hidden" id="judgeBadge">—</span>
              </div>
            </div>

            <div class="prompt" id="promptText">—</div>

            <div class="spell-wrap hidden" id="spellWrap" aria-label="スペル入力">
              <div class="spell-label">SPELLING</div>
              <div class="spell-row">
                <input class="spell-input" id="spellInput" type="text"
                       inputmode="latin" autocomplete="off" autocapitalize="none" autocorrect="off" spellcheck="false"
                       placeholder="ここにスペル（手書き入力/キーボード）" />
                <button class="navbtn hidden" id="readCanvasBtn" title="キャンバスから読み取り">読み取り</button>
              </div>
            </div>

            <div class="answer-wrap hidden" id="answerWrap">
              <div class="answer-label">ANSWER</div>
              <div class="answer" id="answerText">—</div>
              <div class="answer" id="yourText" style="margin-top:6px; color: var(--muted); font-size: 13px;"></div>
            </div>

            <div class="hand-wrap hidden" id="handWrap">
              <div class="hand-title">
                <span>HANDWRITE</span>
                <span class="mini" id="handMini">—</span>
              </div>
              <canvas class="hand-canvas" id="handCanvas" width="800" height="400"></canvas>
              <div class="hand-controls">
                <div class="left">
                  <button class="navbtn" id="clearCanvasBtn" title="消す">消す</button>
                </div>
                <div class="right">
                  <div class="hand-note">判定は「判定」ボタン or Enter のみ。</div>
                </div>
              </div>
            </div>
          </div>

          <div class="controls">
            <div class="left">
              <button class="cta" id="primaryBtn">答えを表示</button>
              <button class="navbtn" id="restartBtn" title="最初から">最初から</button>
              <button class="navbtn hidden" id="newSetBtn" title="抽選し直す">抽選し直す</button>
            </div>

            <div class="right">
              <button class="navbtn" id="prevBtn">前へ</button>
              <button class="navbtn" id="nextBtn">次へ</button>
            </div>
          </div>

          <div class="hint">
            Enter：判定（手書き） / ←→：移動 / Esc：タイトルへ
          </div>

          <div class="debug-bar" id="debugBar"></div>
        </section>

        <!-- Result -->
        <section class="view" id="viewResult" aria-label="結果画面">
          <div class="hero">
            <h2 class="h1" style="font-size:22px">Score</h2>
            <p class="subtitle" id="resultSub">—</p>

            <div class="result-box">
              <div class="scoreline">
                <div class="scorebig" id="scoreBig">—</div>
                <div class="scoresub" id="scoreSub">—</div>
              </div>
            </div>

            <details id="wrongDetails">
              <summary id="wrongSummary">間違い（—）</summary>
              <ul class="wrong-list" id="wrongList"></ul>
            </details>

            <div class="actions" style="margin-top:12px;">
              <button class="btn" id="resultRestartBtn">
                <div class="label">もう一度（同じセット）</div>
                <div class="desc">同じ100問で再挑戦</div>
              </button>
              <button class="btn" id="resultNewSetBtn">
                <div class="label">抽選し直す</div>
                <div class="desc">別の100問で挑戦</div>
              </button>
              <button class="btn" id="resultTitleBtn">
                <div class="label">タイトルへ</div>
                <div class="desc">モード選択へ戻る</div>
              </button>
              <button class="btn" id="resultReviewBtn">
                <div class="label">間違いだけ復習（順番）</div>
                <div class="desc">間違いリストを順番に表示</div>
              </button>
            </div>
          </div>
        </section>
      </div>
    </main>

    <div class="overlay hidden" id="settingsOverlay" role="dialog" aria-modal="true" aria-label="設定">
      <div class="sheet">
        <div class="sheet-header">
          <div class="sheet-title">設定</div>
          <button class="icon-btn" id="closeSettingsBtn" aria-label="閉じる" title="閉じる">✕</button>
        </div>

        <div class="sheet-body">
          <div class="setting">
            <div class="text">
              <div class="name">出題方向</div>
              <div class="note">英語を見て日本語 / 日本語を見て英語（手書き本番は日→英固定）</div>
            </div>
            <div class="seg" role="tablist" aria-label="出題方向">
              <button type="button" id="dirEnJaBtn" class="active" role="tab" aria-selected="true">英 → 日</button>
              <button type="button" id="dirJaEnBtn" role="tab" aria-selected="false">日 → 英</button>
            </div>
          </div>

          <div class="setting">
            <div class="text">
              <div class="name">アニメーション</div>
              <div class="note">フェードのみ。</div>
            </div>
            <label class="toggle" aria-label="アニメーション ON/OFF">
              <input type="checkbox" id="animToggle" />
            </label>
          </div>

          <div class="setting">
            <div class="text">
              <div class="name">効果音</div>
              <div class="note">正解/不正解の音。ループしません。</div>
            </div>
            <label class="toggle" aria-label="効果音 ON/OFF">
              <input type="checkbox" id="sfxToggle" />
            </label>
          </div>

          <div class="setting">
            <div class="text">
              <div class="name">BGM</div>
              <div class="note">問題画面でループ再生。</div>
            </div>
            <label class="toggle" aria-label="BGM ON/OFF">
              <input type="checkbox" id="bgmToggle" />
            </label>
          </div>

          <div class="setting">
            <div class="text">
              <div class="name">データ検証表示</div>
              <div class="note">欠番/重複/解析エラーがある場合に小さく表示。</div>
            </div>
            <label class="toggle" aria-label="データ検証表示 ON/OFF">
              <input type="checkbox" id="debugToggle" />
            </label>
          </div>
        </div>

        <div class="sheet-footer">
          <button class="textbtn" id="closeSettingsBtn2">閉じる</button>
        </div>
      </div>
    </div>

    <div class="corner">
      <div class="version">
        Version 0.5<br />
        © 2026 Your Name
      </div>
    </div>
  </div>

  <script>
    ;(() => {
      "use strict";

      // =========================
      // Audio (user-provided mp3)
      // =========================
      // Change these paths if you want different filenames/locations.
      const AUDIO_PATHS = {
        bgm: "audio/bgm.mp3",
        correct: "Quiz-Ding_Dong02-2(Fast-Single).mp3",
        wrong: "Quiz-Buzzer02-4(Multi).mp3",
      };

      const audio = {
        ready: false,
        bgm: null,
        sfxOk: null,
        sfxNg: null,
      };

      function initAudio(){
        if (audio.ready) return;
        audio.ready = true;

        audio.bgm = new Audio(AUDIO_PATHS.bgm);
        audio.bgm.loop = true;           // BGM must loop
        audio.bgm.preload = "auto";

        audio.sfxOk = new Audio(AUDIO_PATHS.correct);
        audio.sfxOk.loop = false;        // SFX must NOT loop
        audio.sfxOk.preload = "auto";

        audio.sfxNg = new Audio(AUDIO_PATHS.wrong);
        audio.sfxNg.loop = false;        // SFX must NOT loop
        audio.sfxNg.preload = "auto";
      }

      function playBgm(){
        if (!state.settings.bgm) return;
        initAudio();
        if (!audio.bgm) return;
        if (!audio.bgm.paused) return;

        const p = audio.bgm.play();
        if (p && p.catch) p.catch(() => {});
      }

      function stopBgm(){
        if (!audio.ready || !audio.bgm) return;
        audio.bgm.pause();
      }

      function syncBgmToView(){
        if (!state.settings.bgm) { stopBgm(); return; }
        if (state.view === "QUIZ") playBgm();
        else stopBgm();
      }

      function playSfx(kind){
        if (!state.settings.sfx) return;
        initAudio();
        const a = (kind === "ok") ? audio.sfxOk : audio.sfxNg;
        if (!a) return;

        try{
          a.pause();
          a.currentTime = 0;
        } catch {}

        const p = a.play();
        if (p && p.catch) p.catch(() => {});
      }

      // =========================
      // RAW_DATA (confirmed)
      // =========================
      const RAW_DATA_1_200 = `
1 ability 能力，力量 51 maker 製造元，製作者 101 defeat 負かす，打ち破る 151 eager 強く望んでいる，切望している
2 ad 広告，宣伝 52 match 試合，競技 102 destroy を破壊する，を壊す 152 engaged に従事して，忙しくして
3 agenda 議題 53 merchant 商人，販売者 103 disappoint がっかりさせる，失望させる 153 exclusive 閉鎖的な
4 alternative 代替物，代案 54 mixture 混合物，複合体 104 do me a favor お願いをする 154 expensive 高価な，費用のかかる
5 ankle 足首，くるぶし 55 nature 自然，天然 105 dump 投げ捨てる，捨てる 155 fat 太った，肥満した
6 architect 建築家 56 obligation 義務，責任 106 encounter 遭遇する，出会う 156 friendly 友好的な，親切な
7 assistance 支援，手伝い 57 opportunity 機会，好機 107 escape 逃れる，脱走する 157 harsh 厳しい
8 automobile 自動車，乗用車 58 pain 痛み，苦痛 108 exist 存在する，実在する 158 immediate 即座の，瞬時の
9 benefit 利益/に利益をもたらす 59 path 小道，細道 109 extend 延びる，延長する 159 initial 当初の，最初の
10 breast 胸部，胸 60 period 期間，周期 110 flow 流れる，流す 160 latter 後者の，後半の
11 candidate 候補者，志願者 61 pit くぼみ，凹み 111 gather を集める，収集する 161 medium 中間の，中央の
12 chairman 会長 62 politician 政治家，政府要人 112 graduate を卒業する，を修了する 162 naked 裸の，無防備な
13 circuit 回路，巡回 63 prayer 祈り，礼拝 113 hate ひどく嫌う，深く憎む 163 nuclear 核の，中心の
14 coal 石炭，炭 64 principle 原理 114 imitate 模倣する，真似る 164 numerous 多数の，多くの
15 commission 手数料，委任状 65 profit 利益，もうけ 115 inform 情報を与える，に知らせる 165 overwhelming 圧倒的な，支配的な
16 compassion 思いやり 66 proverb ことわざ 116 interrupt 割り込む，中断する 166 plain 簡素な，わかりやすい
17 condition 状態，条件，情勢 67 quantity 量，数値 117 keep in mind を心に留めておく 167 precious 貴重な，大切な
18 constitution 憲法，構成，組織 68 reduction 削減，減少 118 live on 生き続ける，存続する 168 prompt 即座の，直ちに
19 contribution 寄付，貢献 69 representative 代表者，代理人 119 lose 失う，無くす 169 raw 生の，未加工の
20 court 裁判所，法廷 70 restriction 制限，限定 120 manufacturing 製造している 170 responsible 責任がある，責任が伴う
21 criticism 批判，評価 71 rumor うわさ 121 nod うなずく，会釈する 171 secondhand 中古の
22 deadline 締め切り，期限 72 secretary 秘書，秘書官 122 originate 始まる，起こす 172 smart 頭の良い，きちんとした
23 delivery 配達，送付 73 sign 標識，印，合図 123 pitch 投げる，放る 173 stupid 馬鹿な，愚かな
24 destination 目的地，行き先 74 souvenir お土産 124 preserve 保存/を保存する 174 talented 才能のある
25 dignity 威厳，尊厳 75 stock 株，在庫/を在庫に持つ 125 prove を証明する，立証する 175 tough 頑強な，丈夫な
26 disorder 無秩序，混乱 76 substance 物質，実態 126 put together まとめる，一緒にする 176 uncomfortable 心地の悪い，不快な
27 doubt 疑い，疑問 77 supply 供給 127 recognize を認識する，はっきりと知る 177 urgent 緊急の，急を要する
28 economics 経済学，財政学 78 tale お話，物語 128 release 解き放つ，解放する 178 vital 極めて重要な，生命の
29 emergency 緊急事態，緊急 79 term 期間，専門用語 129 reply 返答する，応答する 179 adequate 適切で，十分な
30 environment 環境，状況 80 tissue 細胞組織，薄い織物 130 retire 退職する，引退する 180 aloud 声に出して，大声で
31 evidence 証拠 81 trait 特性，特色 131 run away 逃げ去る，逃亡する 181 bravely 勇敢に，りっぱに
32 expectation 期待，予想 82 truth 真実，事実 132 select を選び出す，を選ぶ 182 especially 特に，格段に
33 extent 程度，大きさ 83 variation 変化，変動 133 slip 滑る 183 forward 前方へ，前に
34 fame 名声 84 vocabulary 単語，語彙 134 spread を広げる，広がる 184 immediately 即座に，直ちに
35 fellow 仲間，友人 85 wisdom 知恵，賢明さ 135 strain 張る，伸ばす 185 later 後に，以後
36 flood 洪水，氾濫 86 abandon を捨て去る，放棄する 136 summon 召喚する 186 nevertheless にも関わらず，けれども
37 fraction 分数 87 acquaint 知らせる 137 take after をまねる，に似る 187 particularly 特に，とりわけ
38 gene 遺伝子，遺因 88 affect に影響を与える，に作用する 138 transfer を移す，を転送する 188 rapidly 素早く，迅速に
39 grace 恵み 89 answer for 責任を負う，引き受ける 139 undertake 引き受ける 189 sincerely 心から，真心こめて
40 harbor 港，港湾 90 argue だと主張する，感情的に論じる 140 wear 身につけている，着用している 190 terribly ひどく，ものすごく
41 hemisphere 半球 91 astonish ひどく驚かす，驚かせる 141 wrap を包む，巻きつける 191 as far as I know 私の知る限り
42 humidity 湿度，湿気 92 beat 打ち負かす 142 wrong 間違い，誤った 192 at one time 一度に，同時に
43 impact 影響，衝撃 93 bleed 出血する 143 aggressive 攻撃的な，侵略的な 193 be familiar with に馴染みがある
44 industry 産業，工業 94 break out 勃発する 144 agricultural 農業の，農作物の 194 before long 間もなく
45 injection 注射，注入 95 capture を捕まえる，捉える 145 artificial 人工的な，人造の 195 for example 例えば，たとえ… としても
46 insurance 保険，保障 96 civilize 文明化する，開化させる 146 biological 生物学上の，生物的な 196 in advance 前もって，事前に
47 joint 継目，関節 97 commute 通勤する，取り替える 147 civil 市民の，住民の 197 in practice 実際には, 実際
48 laboratory 実験室，研究所 98 concern 心配する，に関係する 148 concrete 具体的な，明確な 198 not yet まだ，今のところ
49 layer 層 99 contain を含む，が入っている 149 creative 創造的な，独創的な 199 on the way to 道の途中で
50 litter ごみ 100 criticize を批評する，を評価する 150 desirable 望ましい，理想的な 200 to start with まず第一に，初めに
      `;

      const RAW_DATA_201_400 = `
201 abortion 中絶，妊娠中絶 251 male 男性，雄 301 defend を守る，保護する 351 economic 経済の，財政の
202 addition 追加，付加 252 mate 友達，仲間 302 detect を検出する，を感知する 352 enormous 非常に大きい，極端に大きい
203 agent 代理人，代表者 253 mess 混乱，錯乱，無秩序 303 discover を発見する，見つける 353 expired 期限切れの，契約の切れた
204 altitude 高度 254 moment 瞬間，瞬時 304 do well うまくやる，成功する 354 famous 有名な，著名な
205 anniversary ～周年，記念日 255 navy 海軍，水軍 305 earn 稼ぐ，得る 355 favorite 特に好きな，お気に入りの
206 argument 議論，口論 256 observation 観察，観測 306 encourage を勇気づける，励ます 356 frightened 恐ろしかった，怖かった
207 association 協会，連合 257 opposition 反対，対立 307 establish を設立する，創設する 357 historical 歴史上の，過去の
208 avenue 大通り 258 palm 手のひら，（動物の）前足の裏 308 expand 拡大する，広がる 358 imperial 帝国の
209 beverage 飲料 259 patience 辛抱強さ，忍耐力 309 face 直面する/顔 359 innocent 罪のない，無罪の
210 breath 息，呼吸 260 permission 許可，認可 310 focus on に焦点を合わせる，に注目する 360 lazy 怠け者の，ぐうたらの
211 capacity 容量，容積 261 planet 惑星，天体 311 gaze 凝視する，じっと見る 361 mental 精神の，心の
212 chamber 小部屋，個室 262 politics 政治，政策 312 greet を出迎える，に挨拶する 362 narrow 幅が狭い，細い
213 circumstance 状況，環境 263 predator 捕食者 313 hear from から便りがある，連絡をもらう 363 obvious 明白な，明瞭な
214 coast 海岸，沿岸地域 264 priority 優先度，優越性 314 immigrate 移住する，移転する 364 overall 全体的な，全部の
215 commissioner 委員，理事 265 progress 進歩，前進 315 insist 強く主張する，断言する 365 own 自身の，自分自身の
216 competition 競争 266 province 州，地方 316 introduce 紹介する，引き合わす 366 pleasant 楽しい，愉快な
217 conduct 行為，行動 267 quarrel 喧嘩，口論，言い争い 317 keep up with に遅れず付いていく，遅れないで追随する 367 precise 正確な，的確な
218 construction 建設，構造，建造物 268 reference 参照，参考 318 load 積む/積み荷 368 proper 適切な，ふさわしい
219 conversation 会話，対話 269 republic 共和国，共和制国家 319 made of で出来ている，構成されている 369 rear 後部の，背後の
220 crack 裂け目，ひび 270 result 結果 320 mean を意味する，を示す 370 reverse 反対の，裏側の
221 critics 評論家，批評家 271 sacrifice 犠牲，捧げ物 321 notice 気づく/通知 371 senior ポストが上の/年上の人
222 dealer 販売業者，売り手 272 seed 種子，種 322 overcome を克服する，乗り越える 372 social 社会の，共同体の
223 demand 要求，需要/を要求する 273 silence 沈黙 323 play a role in において役割を果たす 373 subtle 微妙な，繊細な
224 destruction 破壊，壊滅 274 species 種，種族 324 pretend のふりをする，に成りすます 374 technical 技術上の，専門的な
225 direction 方向，方角 275 stomach 腹 325 provide を供給する，提供する 375 toxic 有毒な
226 distance 距離，間隔 276 suburb 郊外，近郊 326 put up with に耐える 376 unexpected 意外な，突然の
227 dozen 12の 277 supporter 支援者，後援者 327 recommend を推薦する，を勧める 377 useful 役に立つ，有用な
228 economy 経済，節約 278 talent 才能，能力 328 relieve 和らげる，軽減する 378 vivid 鮮やかな
229 emperor 皇帝，天皇 279 terror 恐怖，恐れ 329 represent を表す，を代表する 379 accustomed 慣れている，いつもの
230 envy 妬み，羨望 280 toe つま先，足の指 330 reuse を再利用する，再使用する 380 altogether 完全に，まったく
231 evolution 進化，発展 281 transition 遷移，変遷 331 run out of を使い果たす，消耗する 381 briefly 簡単に，手短に
232 expense 費用，出費，犠牲 282 tuition 授業料，学費 332 settle down 定住する 382 essentially 本質的に，根本的に
233 extinction 絶滅，消失 283 vehicle 乗り物，車 333 smell においがする，臭いがする 383 frequently 頻繁に, たびたび
234 famine 食料不足 284 voyage 航海，航行 334 squeeze 絞る，押しつぶす 384 increasingly ますます，更に
235 female 雌の，女性の 285 witness 目撃者，証人/を目撃する 335 strengthen 強化する，増強する 385 literally 文字通りに，直訳で
236 focus 焦点，中心 286 abolish 廃止する 336 suppose だと思う，と仮定する 386 newly 新たに，最近
237 fragment 断片 287 acquire を身につける 337 take care 注意する，警戒する 387 partly 部分的に，一部分
238 generation 世代，年代 288 afford 余裕がある，ゆとりがある 338 transform を変える，を改変する 388 rarely めったに～ない，稀に
239 grammar 文法，文法規則 289 apologize 謝る，謝罪する 339 urge 強く促す，早める 389 slightly わずかに，少し
240 harm 害，危害/を害する 290 arise 起こる，現れる 340 weigh 重さがある，の重さを量る 390 therefore それゆえ，だから
241 heritage 遺産，相続財産 291 attach to に添える，に取り付ける 341 yell 大声で叫ぶ，大声を出す 391 as if まるで～かのように
242 hunger 飢え，空腹 292 beg 懇願する，願い出る 342 absolute 絶対的な，完全な 392 at present 現在は，今は
243 implication 含み，裏の意味 293 blink 瞬きをする，瞬間を過ごす 343 alike よく似た，類似の 393 be filled with で満たされている，充実している
244 infant 乳児，赤ちゃん 294 breathe 呼吸をする 344 armed 武装した，装備した 394 by chance 偶然に，たまたま
245 injury 怪我，負傷 295 carry out を成し遂げる，実行する 345 ashamed 恥じて，恥ずかしくて 395 for free 無料で，無償で
246 intelligence 知能，知性 296 climb 登る，よじ登る 346 bitter 苦い，えぐい 396 in case 万一に備えて
247 journal 日誌，日記 297 compare を比較する，をたとえる 347 civilized 発達した文明をもつ，教養の高い 397 in reality 実際に，現実に
248 lack 不足，欠乏 298 conclude を締めくくる，終える 348 confident 自信のある，確信している 398 nursery school 保育園，幼稚園
249 lecture 講義 299 continue をし続ける，続ける 349 criminal 犯罪の，違法の 399 one day ある日，いつか
250 location 位置，場所 300 cruise 巡航する，航行する 350 detailed 詳細の，具体的な 400 up to ～まで，～に至る
      `;

      const RAW_DATA_ALL = RAW_DATA_1_200 + "\n" + RAW_DATA_201_400;

      // =========================
      // Parse (robust)
      // =========================
      const jpRegex = /[ぁ-んァ-ヶ一-龯]/;

      function parseWords(raw, maxId){
        const normalized = String(raw).replace(/\s+/g, " ").trim();

        // id boundary: 1..400 followed by spaces + ASCII letter (avoid "12の" etc)
        const idRegex = /(^|\s)(400|[1-3]\d{2}|[1-9]\d|[1-9])(?=\s+[A-Za-z])/g;
        const matches = [];
        for (const m of normalized.matchAll(idRegex)){
          const lead = m[1] || "";
          const idStr = m[2];
          const start = (m.index ?? 0) + lead.length;
          const id = Number(idStr);
          if (Number.isFinite(id) && id >= 1 && id <= maxId){
            matches.push({ id, start });
          }
        }

        const found = [];
        const parseErrors = [];

        for (let i = 0; i < matches.length; i++){
          const start = matches[i].start;
          const end = (i + 1 < matches.length) ? matches[i + 1].start : normalized.length;
          const chunk = normalized.slice(start, end).trim();
          const mm = chunk.match(/^(\d+)\s+(.+)$/);
          if (!mm) continue;

          const id = Number(mm[1]);
          if (!(id >= 1 && id <= maxId)) continue;

          const rest = mm[2] ?? "";
          const jpIndex = rest.search(jpRegex);

          let word = "";
          let meaning = "";

          if (jpIndex === -1){
            word = rest.trim();
            meaning = "";
            parseErrors.push(id);
          } else {
            // meaning should start at token containing first JP char (so "12の" keeps 12)
            const prevSpace = rest.lastIndexOf(" ", jpIndex);
            const meaningStart = (prevSpace === -1) ? 0 : (prevSpace + 1);

            word = rest.slice(0, meaningStart).trim();
            meaning = rest.slice(meaningStart).trim();
            if (!word || !meaning) parseErrors.push(id);
          }

          found.push({ id, word, meaning });
        }

        found.sort((a,b) => a.id - b.id);

        const byId = new Map();
        const duplicates = [];
        for (const item of found){
          if (byId.has(item.id)){
            duplicates.push(item.id);
            continue;
          }
          byId.set(item.id, item);
        }

        const missing = [];
        for (let id = 1; id <= maxId; id++){
          if (!byId.has(id)) missing.push(id);
        }

        const parseErrorsUnique = Array.from(new Set(parseErrors)).sort((a,b)=>a-b);
        const words = Array.from(byId.values()).sort((a,b)=>a.id - b.id);

        return {
          maxId,
          words,
          byId,
          missing,
          duplicates: Array.from(new Set(duplicates)).sort((a,b)=>a-b),
          parseErrors: parseErrorsUnique
        };
      }

      function shuffle(arr){
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--){
          const j = Math.floor(Math.random() * (i + 1));
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      }

      function uniq(arr){
        return Array.from(new Set(arr));
      }

      function clamp(n, min, max){
        return Math.max(min, Math.min(max, n));
      }

      // =========================
      // Data
      // =========================
      const data = parseWords(RAW_DATA_ALL, 400);

      // =========================
      // Settings
      // =========================
      const SETTINGS_KEY = "wordPractice400.settings.v2";
      const DECK_KEY = "wordPractice400.deck.v1";
      const EXAM_SET_KEY_PREFIX = "wordPractice400.examSet.v1"; // + ":" + deckKey

      const defaultSettings = {
        direction: "EN_JA",     // EN_JA or JA_EN
        animations: true,
        debug: true,
        sfx: true,
        bgm: true
      };

      function loadSettings(){
        try{
          const raw = localStorage.getItem(SETTINGS_KEY);
          if (!raw) return { ...defaultSettings };
          const parsed = JSON.parse(raw);
          return {
            direction: (parsed.direction === "JA_EN") ? "JA_EN" : "EN_JA",
            animations: ("animations" in parsed) ? !!parsed.animations : defaultSettings.animations,
            debug: ("debug" in parsed) ? !!parsed.debug : defaultSettings.debug,
            sfx: ("sfx" in parsed) ? !!parsed.sfx : defaultSettings.sfx,
            bgm: ("bgm" in parsed) ? !!parsed.bgm : defaultSettings.bgm
          };
        } catch {
          return { ...defaultSettings };
        }
      }
      function saveSettings(s){
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(s));
      }

      function loadDeck(){
        const v = localStorage.getItem(DECK_KEY);
        if (v === "B" || v === "ALL") return v;
        return "A";
      }
      function saveDeck(d){
        localStorage.setItem(DECK_KEY, d);
      }

      // =========================
      // App state
      // =========================
      const state = {
        settings: loadSettings(),
        view: "TITLE",  // TITLE | QUIZ | RESULT
        deck: loadDeck(), // A | B | ALL

        mode: null,     // SEQ | REV | RND | LOOP2 | EXAM | HAND | REVIEW_WRONG
        order: [],
        index: 0,

        showAnswer: false,
        done: false,

        // hand mode
        hand: {
          checked: false,
          correct: null,
          input: "",
          busy: false,
          results: [], // {id, expected, given, correct, promptMeaning}
          scoreCorrect: 0
        },

        // review wrong deck (as order)
        wrongOrder: []
      };

      // =========================
      // Elements
      // =========================
      const el = {
        backBtn: document.getElementById("backBtn"),
        settingsBtn: document.getElementById("settingsBtn"),

        viewTitle: document.getElementById("viewTitle"),
        viewQuiz: document.getElementById("viewQuiz"),
        viewResult: document.getElementById("viewResult"),

        deckABtn: document.getElementById("deckABtn"),
        deckBBtn: document.getElementById("deckBBtn"),
        deckAllBtn: document.getElementById("deckAllBtn"),
        deckStatus: document.getElementById("deckStatus"),
        practiceHint: document.getElementById("practiceHint"),

        startSeqBtn: document.getElementById("startSeqBtn"),
        startRevBtn: document.getElementById("startRevBtn"),
        startRndBtn: document.getElementById("startRndBtn"),
        startLoopBtn: document.getElementById("startLoopBtn"),
        startExamBtn: document.getElementById("startExamBtn"),
        startHandBtn: document.getElementById("startHandBtn"),

        badgeSeq: document.getElementById("badgeSeq"),
        badgeRev: document.getElementById("badgeRev"),
        badgeRnd: document.getElementById("badgeRnd"),
        badgeLoop: document.getElementById("badgeLoop"),
        badgeExam: document.getElementById("badgeExam"),
        badgeHand: document.getElementById("badgeHand"),

        dataStatusText: document.getElementById("dataStatusText"),

        progressText: document.getElementById("progressText"),
        modePill: document.getElementById("modePill"),
        noText: document.getElementById("noText"),
        dirLabel: document.getElementById("dirLabel"),
        judgeBadge: document.getElementById("judgeBadge"),
        promptText: document.getElementById("promptText"),
        answerWrap: document.getElementById("answerWrap"),
        answerText: document.getElementById("answerText"),
        yourText: document.getElementById("yourText"),

        // marks
        markLayer: document.getElementById("markLayer"),
        svgOk: document.getElementById("svgOk"),
        svgNg: document.getElementById("svgNg"),

        spellWrap: document.getElementById("spellWrap"),
        spellInput: document.getElementById("spellInput"),
        readCanvasBtn: document.getElementById("readCanvasBtn"),

        handWrap: document.getElementById("handWrap"),
        handCanvas: document.getElementById("handCanvas"),
        handMini: document.getElementById("handMini"),
        clearCanvasBtn: document.getElementById("clearCanvasBtn"),

        primaryBtn: document.getElementById("primaryBtn"),
        prevBtn: document.getElementById("prevBtn"),
        nextBtn: document.getElementById("nextBtn"),
        restartBtn: document.getElementById("restartBtn"),
        newSetBtn: document.getElementById("newSetBtn"),

        debugBar: document.getElementById("debugBar"),
        card: document.getElementById("card"),

        // settings
        settingsOverlay: document.getElementById("settingsOverlay"),
        closeSettingsBtn: document.getElementById("closeSettingsBtn"),
        closeSettingsBtn2: document.getElementById("closeSettingsBtn2"),
        dirEnJaBtn: document.getElementById("dirEnJaBtn"),
        dirJaEnBtn: document.getElementById("dirJaEnBtn"),
        animToggle: document.getElementById("animToggle"),
        sfxToggle: document.getElementById("sfxToggle"),
        bgmToggle: document.getElementById("bgmToggle"),
        debugToggle: document.getElementById("debugToggle"),

        // result
        resultSub: document.getElementById("resultSub"),
        scoreBig: document.getElementById("scoreBig"),
        scoreSub: document.getElementById("scoreSub"),
        wrongDetails: document.getElementById("wrongDetails"),
        wrongSummary: document.getElementById("wrongSummary"),
        wrongList: document.getElementById("wrongList"),
        resultRestartBtn: document.getElementById("resultRestartBtn"),
        resultNewSetBtn: document.getElementById("resultNewSetBtn"),
        resultTitleBtn: document.getElementById("resultTitleBtn"),
        resultReviewBtn: document.getElementById("resultReviewBtn")
      };

      // =========================
      // Debug summary UI
      // =========================
      function formatList(ids, max = 14){
        if (!ids.length) return "なし";
        const head = ids.slice(0, max).join(", ");
        const tail = ids.length > max ? ` …(+${ids.length - max})` : "";
        return head + tail;
      }

      function updateDataStatus(){
        const ok = (data.words.length === data.maxId) && data.missing.length === 0 && data.duplicates.length === 0 && data.parseErrors.length === 0;
        const parts = [];
        parts.push(ok ? `OK（${data.words.length}/${data.maxId}）` : `注意（${data.words.length}/${data.maxId}）`);
        if (data.missing.length) parts.push(`欠番: ${formatList(data.missing)}`);
        if (data.duplicates.length) parts.push(`重複: ${formatList(data.duplicates)}`);
        if (data.parseErrors.length) parts.push(`解析: ${formatList(data.parseErrors)}`);
        el.dataStatusText.textContent = parts.join(" / ");
      }

      function updateDebugBar(){
        if (!state.settings.debug){
          el.debugBar.textContent = "";
          return;
        }
        const lines = [];
        if (data.missing.length) lines.push(`欠番: ${formatList(data.missing)}`);
        if (data.duplicates.length) lines.push(`重複: ${formatList(data.duplicates)}`);
        if (data.parseErrors.length) lines.push(`解析エラー: ${formatList(data.parseErrors)}`);

        if (!lines.length){
          el.debugBar.textContent = "";
          return;
        }
        el.debugBar.innerHTML = `<strong>Data check</strong> — ${lines.join(" / ")}`;
      }

      // =========================
      // Deck
      // =========================
      function deckLabel(deckKey){
        if (deckKey === "A") return "0〜200";
        if (deckKey === "B") return "200〜400";
        return "ALL";
      }

      function getDeckWords(deckKey){
        if (deckKey === "A") return data.words.filter(w => w.id >= 1 && w.id <= 200);
        if (deckKey === "B") return data.words.filter(w => w.id >= 201 && w.id <= 400);
        return data.words.slice();
      }

      function deckSize(deckKey){
        return getDeckWords(deckKey).length;
      }

      // =========================
      // Mode labels
      // =========================
      function modeLabel(){
        switch (state.mode){
          case "SEQ": return "順番";
          case "REV": return "逆順";
          case "RND": return "ランダム（1周）";
          case "LOOP2": return "ランダム周回（2周）";
          case "EXAM": return "本番（100問）";
          case "HAND": return "手書き本番（100問）";
          case "REVIEW_WRONG": return "間違い復習";
          default: return "—";
        }
      }

      function dirLabel(){
        if (state.mode === "HAND") return "手書き：日 → 英（固定）";
        return state.settings.direction === "EN_JA" ? "英 → 日" : "日 → 英";
      }

      // =========================
      // View + render helpers
      // =========================
      function setView(next){
        state.view = next;

        el.viewTitle.classList.toggle("active", next === "TITLE");
        el.viewQuiz.classList.toggle("active", next === "QUIZ");
        el.viewResult.classList.toggle("active", next === "RESULT");

        el.backBtn.disabled = (next === "TITLE");

        // keep BGM synced to view (quiz only)
        syncBgmToView();
      }

      function animateCardSwap(fnRender){
        if (!state.settings.animations){
          fnRender();
          return;
        }
        el.card.classList.add("fade-out");
        window.setTimeout(() => {
          fnRender();
          el.card.classList.remove("fade-out");
        }, 140);
      }

      function getCurrent(){
        if (!state.order.length) return null;
        return state.order[state.index] || null;
      }

      // =========================
      // Build order
      // =========================
      const EXAM_SET_KEY = () => `${EXAM_SET_KEY_PREFIX}:${state.deck}`;

      function sampleIdsUnique(ids, n){
        return shuffle(ids).slice(0, Math.min(n, ids.length));
      }

      function loadExamSetIds(deckKey){
        try{
          const raw = localStorage.getItem(`${EXAM_SET_KEY_PREFIX}:${deckKey}`);
          if (!raw) return null;
          const obj = JSON.parse(raw);
          if (!obj || !Array.isArray(obj.ids)) return null;
          const ids = obj.ids.map(Number).filter(n => Number.isFinite(n));
          return ids.length ? ids : null;
        } catch {
          return null;
        }
      }

      function saveExamSetIds(deckKey, ids){
        const payload = { ids: ids.slice(), createdAt: Date.now() };
        localStorage.setItem(`${EXAM_SET_KEY_PREFIX}:${deckKey}`, JSON.stringify(payload));
      }

      function createExamSetIds(deckKey, forceNew = false){
        const deck = getDeckWords(deckKey);
        const baseIds = deck.map(w => w.id);
        const want = Math.min(100, baseIds.length);
        const existing = loadExamSetIds(deckKey);
        if (!forceNew && existing && existing.length){
          const set = existing.filter(id => baseIds.includes(id));
          if (set.length) return set.slice(0, want);
        }
        const ids = sampleIdsUnique(baseIds, want);
        saveExamSetIds(deckKey, ids);
        return ids;
      }

      function buildOrder(mode){
        const base = getDeckWords(state.deck);

        if (mode === "SEQ") return base.slice();
        if (mode === "REV") return base.slice().reverse();
        if (mode === "RND") return shuffle(base);

        if (mode === "LOOP2"){
          const out = [];
          for (let i = 0; i < 2; i++){
            out.push(...shuffle(base));
          }
          return out;
        }

        if (mode === "EXAM" || mode === "HAND"){
          const ids = createExamSetIds(state.deck, false);
          const out = [];
          for (const id of ids){
            const w = data.byId.get(id);
            if (w) out.push(w);
          }
          return out;
        }

        if (mode === "REVIEW_WRONG"){
          return state.wrongOrder.slice();
        }

        return base.slice();
      }

      // =========================
      // Prompt/Answer
      // =========================
      function displayPromptAnswer(wordObj){
        if (state.mode === "HAND"){
          return { prompt: wordObj.meaning, answer: wordObj.word };
        }
        const isEnJa = state.settings.direction === "EN_JA";
        return { prompt: isEnJa ? wordObj.word : wordObj.meaning, answer: isEnJa ? wordObj.meaning : wordObj.word };
      }

      // =========================
      // Handwriting helpers
      // =========================
      let canvasCtx = null;
      let drawing = false;

      function ensureCanvasReady(){
        if (!el.handCanvas) return;
        if (!canvasCtx){
          canvasCtx = el.handCanvas.getContext("2d", { alpha: false });
        }
        resizeCanvasToCSS();
        primeCanvasStyle();
      }

      function primeCanvasStyle(){
        if (!canvasCtx) return;
        canvasCtx.lineCap = "round";
        canvasCtx.lineJoin = "round";
        canvasCtx.strokeStyle = "#111214";
        canvasCtx.lineWidth = 3.2;
      }

      function resizeCanvasToCSS(){
        if (!el.handCanvas || !canvasCtx) return;
        const rect = el.handCanvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;

        const w = Math.max(1, Math.round(rect.width * dpr));
        const h = Math.max(1, Math.round(rect.height * dpr));

        if (el.handCanvas.width !== w || el.handCanvas.height !== h){
          el.handCanvas.width = w;
          el.handCanvas.height = h;
          canvasCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
          clearCanvas();
          primeCanvasStyle();
        }
      }

      function clearCanvas(){
        if (!canvasCtx || !el.handCanvas) return;
        canvasCtx.save();
        canvasCtx.setTransform(1,0,0,1,0,0);
        canvasCtx.fillStyle = "#ffffff";
        canvasCtx.fillRect(0,0, el.handCanvas.width, el.handCanvas.height);
        canvasCtx.restore();
        primeCanvasStyle();
      }

      function canvasPointFromEvent(e){
        const r = el.handCanvas.getBoundingClientRect();
        return { x: e.clientX - r.left, y: e.clientY - r.top };
      }

      function bindCanvasEvents(){
        if (!el.handCanvas) return;

        el.handCanvas.addEventListener("pointerdown", (e) => {
          if (state.mode !== "HAND") return;
          ensureCanvasReady();
          drawing = true;
          el.handCanvas.setPointerCapture(e.pointerId);
          const p = canvasPointFromEvent(e);
          canvasCtx.beginPath();
          canvasCtx.moveTo(p.x, p.y);
        });

        el.handCanvas.addEventListener("pointermove", (e) => {
          if (state.mode !== "HAND") return;
          if (!drawing) return;
          const p = canvasPointFromEvent(e);
          canvasCtx.lineTo(p.x, p.y);
          canvasCtx.stroke();
        });

        const end = () => { drawing = false; };
        el.handCanvas.addEventListener("pointerup", end);
        el.handCanvas.addEventListener("pointercancel", end);
        el.handCanvas.addEventListener("pointerleave", end);

        window.addEventListener("resize", () => {
          if (state.mode === "HAND"){
            ensureCanvasReady();
          }
        });
      }

      function normalizeCompare(s){
        return String(s || "")
          .toLowerCase()
          .trim()
          .replace(/\s+/g, " ");
      }

      function normalizeNoSpace(s){
        return normalizeCompare(s).replace(/\s+/g, "");
      }

      function computeCorrect(expected, given){
        const a = normalizeCompare(expected);
        const b = normalizeCompare(given);
        if (!a || !b) return false;
        if (a === b) return true;
        // allow ignoring spaces (helps recognition for phrases)
        return normalizeNoSpace(a) === normalizeNoSpace(b);
      }

      function resetHandPerQuestion(){
        state.hand.checked = false;
        state.hand.correct = null;
        state.hand.input = "";
        state.hand.busy = false;

        el.spellInput.value = "";
        el.spellInput.disabled = false;

        // judge badge
        el.judgeBadge.classList.add("hidden");
        el.judgeBadge.classList.remove("ok","ng");
        el.judgeBadge.textContent = "—";

        // answer area
        el.yourText.textContent = "";

        // marks
        hideMark();

        // buttons
        el.primaryBtn.disabled = false;
        el.primaryBtn.textContent = "判定";

        ensureCanvasReady();
        clearCanvas();
      }

      function escapeHtml(s){
        return String(s ?? "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      // =========================
      // OCR (TextDetector) with preprocessing
      // =========================
      function hasTextDetector(){
        return ("TextDetector" in window);
      }

      function cleanOCRText(raw){
        // keep letters and spaces; normalize spaces
        return String(raw || "")
          .replace(/[^A-Za-z\s]/g, " ")
          .replace(/\s+/g, " ")
          .trim();
      }

      function levenshtein(a, b){
        a = normalizeNoSpace(a);
        b = normalizeNoSpace(b);
        const n = a.length;
        const m = b.length;
        if (n === 0) return m;
        if (m === 0) return n;
        const dp = new Array(m + 1);
        for (let j = 0; j <= m; j++) dp[j] = j;

        for (let i = 1; i <= n; i++){
          let prev = dp[0];
          dp[0] = i;
          for (let j = 1; j <= m; j++){
            const tmp = dp[j];
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            dp[j] = Math.min(
              dp[j] + 1,
              dp[j - 1] + 1,
              prev + cost
            );
            prev = tmp;
          }
        }
        return dp[m];
      }

      function cropAndScaleForOCR(srcCanvas){
        const w = srcCanvas.width;
        const h = srcCanvas.height;

        const tmp = document.createElement("canvas");
        tmp.width = w;
        tmp.height = h;
        const tctx = tmp.getContext("2d", { alpha: false });
        tctx.drawImage(srcCanvas, 0, 0);

        const img = tctx.getImageData(0, 0, w, h);
        const d = img.data;

        let minX = w, minY = h, maxX = 0, maxY = 0;
        let found = false;

        const step = 2;
        const thr = 235;
        for (let y = 0; y < h; y += step){
          for (let x = 0; x < w; x += step){
            const i = (y * w + x) * 4;
            const r = d[i], g = d[i+1], b = d[i+2];
            const lum = 0.2126*r + 0.7152*g + 0.0722*b;
            if (lum < thr){
              found = true;
              if (x < minX) minX = x;
              if (y < minY) minY = y;
              if (x > maxX) maxX = x;
              if (y > maxY) maxY = y;
            }
          }
        }

        if (!found){
          return srcCanvas;
        }

        const pad = Math.round(Math.min(w, h) * 0.05) + 14;
        const sx = clamp(minX - pad, 0, w - 1);
        const sy = clamp(minY - pad, 0, h - 1);
        const ex = clamp(maxX + pad, 0, w - 1);
        const ey = clamp(maxY + pad, 0, h - 1);
        const sw = Math.max(1, ex - sx);
        const sh = Math.max(1, ey - sy);

        const scale = 2.0;
        const out = document.createElement("canvas");
        out.width = Math.max(1, Math.round(sw * scale));
        out.height = Math.max(1, Math.round(sh * scale));
        const octx = out.getContext("2d", { alpha: false });

        octx.fillStyle = "#ffffff";
        octx.fillRect(0,0,out.width,out.height);
        octx.imageSmoothingEnabled = true;
        octx.drawImage(srcCanvas, sx, sy, sw, sh, 0, 0, out.width, out.height);

        const oimg = octx.getImageData(0,0,out.width,out.height);
        const od = oimg.data;
        let sum = 0;
        const count = out.width * out.height;
        for (let i = 0; i < od.length; i += 4){
          const lum = 0.2126*od[i] + 0.7152*od[i+1] + 0.0722*od[i+2];
          sum += lum;
        }
        const avg = sum / count;
        const th2 = clamp(avg - 18, 175, 238);

        for (let i = 0; i < od.length; i += 4){
          const lum = 0.2126*od[i] + 0.7152*od[i+1] + 0.0722*od[i+2];
          const v = lum < th2 ? 0 : 255;
          od[i] = od[i+1] = od[i+2] = v;
          od[i+3] = 255;
        }
        octx.putImageData(oimg, 0, 0);

        return out;
      }

      async function detectTextFromCanvasProcessed(){
        if (!hasTextDetector()) return null;
        try{
          const detector = new TextDetector();
          const processed = cropAndScaleForOCR(el.handCanvas);
          const results = await detector.detect(processed);
          const raw = results.map(r => r.rawValue).join(" ").trim();
          return raw || null;
        } catch {
          return null;
        }
      }

      function pickBestCandidate(raw, expected){
        const cleaned = cleanOCRText(raw);
        if (!cleaned) return null;

        const candidates = new Set();
        candidates.add(cleaned);

        const tokens = cleaned.split(" ").filter(Boolean);
        if (tokens.length) {
          candidates.add(tokens.join(" "));
          candidates.add(tokens.join(""));
        }
        if (tokens.length >= 1){
          candidates.add(tokens[0]);
          candidates.add(tokens[tokens.length - 1]);
        }

        let best = null;
        let bestDist = Infinity;
        for (const c of candidates){
          const dist = levenshtein(expected, c);
          if (dist < bestDist){
            bestDist = dist;
            best = c;
          }
        }
        return best || cleaned;
      }

      async function readCanvasIntoInput(expected){
        const raw = await detectTextFromCanvasProcessed();
        if (!raw) return null;
        const best = pickBestCandidate(raw, expected);
        if (!best) return null;
        el.spellInput.value = best;
        return best;
      }

      // =========================
      // Marks (maru/batsu)
      // =========================
      function hideMark(){
        el.markLayer.classList.add("hidden");
        el.markLayer.classList.remove("show","ok","ng");
        el.svgOk.classList.add("hidden");
        el.svgNg.classList.add("hidden");
      }

      function showMark(isCorrect){
        el.markLayer.classList.remove("ok","ng");
        el.markLayer.classList.remove("show");
        el.markLayer.classList.remove("hidden");

        el.svgOk.classList.toggle("hidden", !isCorrect);
        el.svgNg.classList.toggle("hidden", isCorrect);

        void el.markLayer.offsetWidth;

        el.markLayer.classList.add(isCorrect ? "ok" : "ng");
        el.markLayer.classList.add("show");

        window.setTimeout(() => {
          el.markLayer.classList.remove("show");
          window.setTimeout(() => {
            el.markLayer.classList.add("hidden");
          }, 220);
        }, 900);
      }

      // =========================
      // Check (hand mode)
      // =========================
      async function checkHand(){
        const cur = getCurrent();
        if (!cur) return;
        if (state.hand.checked) return;
        if (state.hand.busy) return;

        state.hand.busy = true;
        el.primaryBtn.disabled = true;

        // If input empty and detector exists, try OCR automatically
        let given = (el.spellInput.value || "").trim();
        if (!given && hasTextDetector()){
          el.primaryBtn.textContent = "読み取り中…";
          await readCanvasIntoInput(cur.word);
          given = (el.spellInput.value || "").trim();
        }

        const expected = cur.word;
        const correct = computeCorrect(expected, given);

        // sound (SFX only, never loop)
        playSfx(correct ? "ok" : "ng");

        state.hand.checked = true;
        state.hand.correct = correct;
        state.hand.input = given;

        state.hand.results.push({
          id: cur.id,
          expected: cur.word,
          given: given,
          correct: correct,
          promptMeaning: cur.meaning
        });

        if (correct) state.hand.scoreCorrect += 1;

        // UI
        el.spellInput.disabled = true;

        el.judgeBadge.classList.remove("hidden");
        el.judgeBadge.classList.toggle("ok", correct);
        el.judgeBadge.classList.toggle("ng", !correct);
        el.judgeBadge.textContent = correct ? "Correct" : "Wrong";

        showMark(correct);

        el.answerWrap.classList.remove("hidden");
        el.answerText.textContent = cur.word;
        el.yourText.textContent = given ? `あなた：${given}` : "あなた：（未入力）";

        el.primaryBtn.textContent = "判定済み";
        el.primaryBtn.disabled = true;

        state.hand.busy = false;

        renderHeaderOnly();
      }

      // =========================
      // Render
      // =========================
      function renderTitleHeader(){
        const d = state.deck;
        el.deckABtn.classList.toggle("active", d === "A");
        el.deckABtn.setAttribute("aria-selected", String(d === "A"));
        el.deckBBtn.classList.toggle("active", d === "B");
        el.deckBBtn.setAttribute("aria-selected", String(d === "B"));
        el.deckAllBtn.classList.toggle("active", d === "ALL");
        el.deckAllBtn.setAttribute("aria-selected", String(d === "ALL"));

        const sizeA = deckSize("A");
        const sizeB = deckSize("B");
        const sizeAll = deckSize("ALL");
        el.deckStatus.textContent = `0〜200: ${sizeA} / 200   |   200〜400: ${sizeB} / 200   |   ALL: ${sizeAll} / 400`;

        const curSize = deckSize(state.deck);
        el.practiceHint.textContent = `選択範囲：${deckLabel(state.deck)}（${curSize}語）`;

        el.badgeSeq.textContent = `${curSize}`;
        el.badgeRev.textContent = `${curSize}`;
        el.badgeRnd.textContent = `${curSize}`;
        el.badgeLoop.textContent = `${curSize * 2}`;
        el.badgeExam.textContent = `${Math.min(100, curSize)}`;
        el.badgeHand.textContent = `${Math.min(100, curSize)}`;

        const can = curSize > 0;
        el.startSeqBtn.disabled = !can;
        el.startRevBtn.disabled = !can;
        el.startRndBtn.disabled = !can;
        el.startLoopBtn.disabled = !can;
        el.startExamBtn.disabled = !can;
        el.startHandBtn.disabled = !can;
      }

      function renderHeaderOnly(){
        const total = state.order.length || 0;
        const qIndex = clamp(state.index + 1, 0, total);

        if (state.mode === "HAND"){
          const corr = state.hand.scoreCorrect;
          el.progressText.innerHTML = `<strong>${qIndex}</strong> / ${total}（正解 ${corr}）`;
        } else {
          el.progressText.innerHTML = `<strong>${qIndex}</strong> / ${total}`;
        }

        el.modePill.textContent = `${deckLabel(state.deck)} · ${modeLabel()}`;
        el.dirLabel.textContent = dirLabel();
      }

      function renderQuestion(){
        const cur = getCurrent();
        if (!cur){
          el.noText.textContent = "No.—";
          el.promptText.textContent = "データがありません";
          el.answerText.textContent = "";
          el.answerWrap.classList.add("hidden");
          el.spellWrap.classList.add("hidden");
          el.handWrap.classList.add("hidden");
          hideMark();
          return;
        }

        renderHeaderOnly();
        el.noText.textContent = `No.${cur.id}`;

        const { prompt, answer } = displayPromptAnswer(cur);
        el.promptText.textContent = prompt;

        const allowPrev = (state.mode === "SEQ" || state.mode === "REV" || state.mode === "LOOP2" || state.mode === "REVIEW_WRONG");
        el.prevBtn.classList.toggle("hidden", !allowPrev);
        el.prevBtn.disabled = !allowPrev || state.index === 0;

        const isExamFamily = (state.mode === "EXAM" || state.mode === "HAND");
        el.newSetBtn.classList.toggle("hidden", !isExamFamily);

        const isHand = (state.mode === "HAND");
        el.spellWrap.classList.toggle("hidden", !isHand);
        el.handWrap.classList.toggle("hidden", !isHand);

        if (isHand){
          el.handMini.textContent = hasTextDetector() ? "読み取り対応" : "読み取り未対応";
          el.readCanvasBtn.classList.toggle("hidden", !hasTextDetector());

          el.primaryBtn.textContent = state.hand.checked ? "判定済み" : (state.hand.busy ? "読み取り中…" : "判定");
          el.primaryBtn.disabled = state.hand.checked || state.hand.busy;

          if (!state.hand.checked){
            el.answerWrap.classList.add("hidden");
            el.answerText.textContent = answer;
            el.yourText.textContent = "";
            hideMark();
          } else {
            el.answerWrap.classList.remove("hidden");
            el.answerText.textContent = answer;
          }

          if (!state.hand.checked){
            el.judgeBadge.classList.add("hidden");
            el.judgeBadge.classList.remove("ok","ng");
            el.judgeBadge.textContent = "—";
          }

        } else {
          el.readCanvasBtn.classList.add("hidden");
          hideMark();

          el.primaryBtn.disabled = false;
          if (state.showAnswer){
            el.answerWrap.classList.remove("hidden");
            el.answerText.textContent = answer;
            el.yourText.textContent = "";
            el.primaryBtn.textContent = "答えを隠す";
          } else {
            el.answerWrap.classList.add("hidden");
            el.answerText.textContent = answer;
            el.yourText.textContent = "";
            el.primaryBtn.textContent = "答えを表示";
          }

          el.judgeBadge.classList.add("hidden");
          el.judgeBadge.classList.remove("ok","ng");
          el.judgeBadge.textContent = "—";
        }

        if (state.mode === "HAND"){
          el.nextBtn.textContent = (state.index >= state.order.length - 1) ? "結果へ" : "次へ";
        } else if (state.done){
          el.nextBtn.textContent = "終了";
        } else {
          el.nextBtn.textContent = (state.index >= state.order.length - 1) ? "完了" : "次へ";
        }
        el.nextBtn.disabled = false;
      }

      function renderResult(){
        const total = state.hand.results.length;
        const correct = state.hand.scoreCorrect;
        const pct = total ? Math.round((correct / total) * 1000) / 10 : 0;

        el.resultSub.textContent = `${deckLabel(state.deck)} · 手書き本番（${total}問）`;
        el.scoreBig.textContent = `${correct} / ${total}`;
        el.scoreSub.textContent = `正答率 ${pct}%`;

        const wrong = state.hand.results.filter(r => !r.correct);
        el.wrongSummary.textContent = `間違い（${wrong.length}）`;
        el.wrongList.innerHTML = "";

        if (wrong.length === 0){
          el.wrongList.innerHTML = `<li class="wrong-item"><div class="mid">全問正解</div></li>`;
          el.wrongDetails.open = false;
        } else {
          for (const r of wrong){
            const li = document.createElement("li");
            li.className = "wrong-item";
            li.innerHTML = `
              <div class="top"><span>No.${r.id}</span><span>日→英</span></div>
              <div class="mid">
                <div style="margin-bottom:6px; color: var(--muted);">${escapeHtml(r.promptMeaning)}</div>
                <div>あなた：<code>${escapeHtml((r.given || "").trim() || "（未入力）")}</code></div>
                <div>正解：<code>${escapeHtml(r.expected)}</code></div>
              </div>
            `;
            el.wrongList.appendChild(li);
          }
          el.wrongDetails.open = true;
        }
      }

      function renderAll(){
        updateDataStatus();
        updateDebugBar();

        const isEnJa = state.settings.direction === "EN_JA";
        el.dirEnJaBtn.classList.toggle("active", isEnJa);
        el.dirEnJaBtn.setAttribute("aria-selected", String(isEnJa));
        el.dirJaEnBtn.classList.toggle("active", !isEnJa);
        el.dirJaEnBtn.setAttribute("aria-selected", String(!isEnJa));

        el.animToggle.checked = state.settings.animations;
        el.sfxToggle.checked = state.settings.sfx;
        el.bgmToggle.checked = state.settings.bgm;
        el.debugToggle.checked = state.settings.debug;

        if (state.view === "TITLE"){
          renderTitleHeader();
        } else if (state.view === "QUIZ"){
          renderQuestion();
        } else if (state.view === "RESULT"){
          renderResult();
        }
      }

      // =========================
      // Navigation
      // =========================
      function startMode(mode){
        state.mode = mode;
        state.index = 0;
        state.showAnswer = false;
        state.done = false;

        if (mode === "HAND"){
          state.hand.checked = false;
          state.hand.correct = null;
          state.hand.input = "";
          state.hand.busy = false;
          state.hand.results = [];
          state.hand.scoreCorrect = 0;
        }

        state.order = buildOrder(mode);

        setView("QUIZ");
        if (mode === "HAND") resetHandPerQuestion();

        // start BGM via user gesture (this call is inside click handler)
        syncBgmToView();

        animateCardSwap(renderAll);
      }

      function goTitle(){
        state.mode = null;
        state.order = [];
        state.index = 0;
        state.showAnswer = false;
        state.done = false;
        setView("TITLE");
        renderAll();
      }

      function goResult(){
        setView("RESULT");
        renderAll();
      }

      function next(){
        if (state.view !== "QUIZ") return;

        if (state.mode === "HAND"){
          // IMPORTANT: NO auto-judge here.
          if (!state.hand.checked) return;

          if (state.index >= state.order.length - 1){
            goResult();
            return;
          }

          state.index += 1;
          resetHandPerQuestion();
          animateCardSwap(renderAll);
          return;
        }

        if (state.done){
          goTitle();
          return;
        }

        if (state.index >= state.order.length - 1){
          state.done = true;
          state.showAnswer = true;
          animateCardSwap(renderAll);
          return;
        }

        state.index += 1;
        state.showAnswer = false;
        animateCardSwap(renderAll);
      }

      function prev(){
        if (state.view !== "QUIZ") return;

        const allowPrev = (state.mode === "SEQ" || state.mode === "REV" || state.mode === "LOOP2" || state.mode === "REVIEW_WRONG");
        if (!allowPrev) return;
        if (state.index <= 0) return;

        state.index -= 1;
        state.showAnswer = false;

        animateCardSwap(renderAll);
      }

      function primaryAction(){
        if (state.view !== "QUIZ") return;

        if (state.mode === "HAND"){
          checkHand();
          return;
        }

        state.showAnswer = !state.showAnswer;
        animateCardSwap(renderAll);
      }

      function restart(){
        if (state.view !== "QUIZ") return;

        state.index = 0;
        state.done = false;
        state.showAnswer = false;

        if (state.mode === "RND"){
          state.order = buildOrder("RND");
        } else if (state.mode === "LOOP2"){
          state.order = buildOrder("LOOP2");
        } else if (state.mode === "EXAM"){
          state.order = buildOrder("EXAM");
        } else if (state.mode === "HAND"){
          state.hand.checked = false;
          state.hand.correct = null;
          state.hand.input = "";
          state.hand.busy = false;
          state.hand.results = [];
          state.hand.scoreCorrect = 0;
          state.order = buildOrder("HAND");
          resetHandPerQuestion();
        } else if (state.mode === "SEQ" || state.mode === "REV"){
          state.order = buildOrder(state.mode);
        } else if (state.mode === "REVIEW_WRONG"){
          state.order = buildOrder("REVIEW_WRONG");
        }

        animateCardSwap(renderAll);
      }

      function newExamSet(){
        if (!(state.mode === "EXAM" || state.mode === "HAND")) return;
        createExamSetIds(state.deck, true); // force new
        restart();
      }

      function setDeck(deckKey){
        state.deck = deckKey;
        saveDeck(deckKey);
        renderAll();
      }

      // =========================
      // Settings overlay
      // =========================
      function openSettings(){ el.settingsOverlay.classList.remove("hidden"); }
      function closeSettings(){ el.settingsOverlay.classList.add("hidden"); }

      function setDirection(dir){
        state.settings.direction = (dir === "JA_EN") ? "JA_EN" : "EN_JA";
        saveSettings(state.settings);
        renderAll();
      }
      function setAnimations(on){
        state.settings.animations = !!on;
        saveSettings(state.settings);
        renderAll();
      }
      function setSfx(on){
        state.settings.sfx = !!on;
        saveSettings(state.settings);
        renderAll();
      }
      function setBgm(on){
        state.settings.bgm = !!on;
        saveSettings(state.settings);
        syncBgmToView(); // start/stop immediately
        renderAll();
      }
      function setDebug(on){
        state.settings.debug = !!on;
        saveSettings(state.settings);
        renderAll();
      }

      // =========================
      // Result actions
      // =========================
      function buildWrongOrderFromResults(){
        const wrongIds = state.hand.results.filter(r => !r.correct).map(r => r.id);
        const ids = uniq(wrongIds);
        const out = [];
        for (const id of ids){
          const w = data.byId.get(id);
          if (w) out.push(w);
        }
        out.sort((a,b)=>a.id-b.id);
        return out;
      }

      function reviewWrong(){
        const wrong = buildWrongOrderFromResults();
        state.wrongOrder = wrong;
        if (!wrong.length){
          goTitle();
          return;
        }
        state.mode = "REVIEW_WRONG";
        state.order = wrong;
        state.index = 0;
        state.showAnswer = false;
        state.done = false;
        setView("QUIZ");
        animateCardSwap(renderAll);
      }

      // =========================
      // Events
      // =========================
      el.deckABtn.addEventListener("click", () => setDeck("A"));
      el.deckBBtn.addEventListener("click", () => setDeck("B"));
      el.deckAllBtn.addEventListener("click", () => setDeck("ALL"));

      el.startSeqBtn.addEventListener("click", () => startMode("SEQ"));
      el.startRevBtn.addEventListener("click", () => startMode("REV"));
      el.startRndBtn.addEventListener("click", () => startMode("RND"));
      el.startLoopBtn.addEventListener("click", () => startMode("LOOP2"));
      el.startExamBtn.addEventListener("click", () => startMode("EXAM"));
      el.startHandBtn.addEventListener("click", () => startMode("HAND"));

      el.backBtn.addEventListener("click", goTitle);
      el.primaryBtn.addEventListener("click", primaryAction);
      el.nextBtn.addEventListener("click", next);
      el.prevBtn.addEventListener("click", prev);
      el.restartBtn.addEventListener("click", restart);
      el.newSetBtn.addEventListener("click", newExamSet);

      el.clearCanvasBtn.addEventListener("click", () => {
        if (state.mode === "HAND"){
          ensureCanvasReady();
          clearCanvas();
        }
      });

      el.readCanvasBtn.addEventListener("click", async () => {
        if (state.mode !== "HAND") return;
        const cur = getCurrent();
        if (!cur) return;
        await readCanvasIntoInput(cur.word);
      });

      el.settingsBtn.addEventListener("click", openSettings);
      el.closeSettingsBtn.addEventListener("click", closeSettings);
      el.closeSettingsBtn2.addEventListener("click", closeSettings);
      el.settingsOverlay.addEventListener("click", (e) => {
        if (e.target === el.settingsOverlay) closeSettings();
      });

      el.dirEnJaBtn.addEventListener("click", () => setDirection("EN_JA"));
      el.dirJaEnBtn.addEventListener("click", () => setDirection("JA_EN"));
      el.animToggle.addEventListener("change", (e) => setAnimations(e.target.checked));
      el.sfxToggle.addEventListener("change", (e) => setSfx(e.target.checked));
      el.bgmToggle.addEventListener("change", (e) => setBgm(e.target.checked));
      el.debugToggle.addEventListener("change", (e) => setDebug(e.target.checked));

      el.resultRestartBtn.addEventListener("click", () => {
        state.mode = "HAND";
        state.order = buildOrder("HAND"); // uses stored ids
        state.index = 0;
        state.showAnswer = false;
        state.done = false;

        state.hand.checked = false;
        state.hand.correct = null;
        state.hand.input = "";
        state.hand.busy = false;
        state.hand.results = [];
        state.hand.scoreCorrect = 0;

        setView("QUIZ");
        resetHandPerQuestion();
        animateCardSwap(renderAll);
      });

      el.resultNewSetBtn.addEventListener("click", () => {
        createExamSetIds(state.deck, true);
        startMode("HAND");
      });

      el.resultTitleBtn.addEventListener("click", goTitle);
      el.resultReviewBtn.addEventListener("click", reviewWrong);

      // keyboard
      document.addEventListener("keydown", (e) => {
        // settings open: only Esc
        if (el.settingsOverlay && !el.settingsOverlay.classList.contains("hidden")){
          if (e.key === "Escape"){
            e.preventDefault();
            closeSettings();
          }
          return;
        }

        // typing focus: do not hijack keys (fix: allow typing "c" and spaces)
        const ae = document.activeElement;
        const isTyping = ae && (ae.tagName === "INPUT" || ae.tagName === "TEXTAREA" || ae.isContentEditable);

        // global escape to title
        if (e.key === "Escape"){
          if (state.view !== "TITLE"){
            e.preventDefault();
            goTitle();
          }
          return;
        }

        if (state.view !== "QUIZ") return;

        // Hand mode: only Enter triggers judge (or Enter again to go next). NO SPACE judge.
        if (state.mode === "HAND"){
          if (e.key === "Enter"){
            e.preventDefault();
            if (!state.hand.checked) checkHand();
            else next();
            return;
          }

          // allow typing keys freely when input is focused
          if (isTyping) return;

          // optional shortcut: clear canvas with C only when not typing
          if (e.key && e.key.toLowerCase() === "c"){
            e.preventDefault();
            ensureCanvasReady();
            clearCanvas();
            return;
          }

          if (e.key === "ArrowRight"){
            e.preventDefault();
            next();
            return;
          }
          if (e.key === "ArrowLeft"){
            e.preventDefault();
            prev();
            return;
          }

          // Do not use Space for anything in HAND mode
          return;
        }

        // Non-hand modes: Space toggles answer
        if (isTyping) return;
        if (e.key === " "){
          e.preventDefault();
          primaryAction();
          return;
        }
        if (e.key === "ArrowRight"){
          e.preventDefault();
          next();
          return;
        }
        if (e.key === "ArrowLeft"){
          e.preventDefault();
          prev();
          return;
        }
      });

      // canvas init
      bindCanvasEvents();

      // Boot
      setView("TITLE");
      renderAll();
    })();
  </script>
</body>
</html>
